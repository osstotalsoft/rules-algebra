{-# LANGUAGE FlexibleInstances #-}

module RulesAlgebra where

import Control.Monad
import Control.Monad.State

data Lens a b = Lens
  { getL :: a -> b,
    setL :: a -> b -> a
  }

data Ctx s = Ctx {document :: s, prevDocument :: s}

type Rule s a = a -> State (Ctx s) a

compose :: Rule s a -> Rule s a -> Rule s a
compose r1 r2 = r1 >=> r2

type Predicate s = Ctx s -> Bool

-- implementation
data Person = Person {personId :: Int, fName :: String, lName :: String, fullName :: String, address :: Address, version :: Int} deriving (Show)

data Address = Address {city :: String, number :: Int} deriving (Show)

-- autogenerated stuff
personId' :: Lens Person Int
personId' = Lens personId (\person personId -> person {personId = personId})

fName' :: Lens Person String
fName' = Lens fName (\person fName -> person {fName = fName})

lName' :: Lens Person String
lName' = Lens lName (\person lName -> person {lName = lName})

fullName' :: Lens Person String
fullName' = Lens fullName (\person fullName -> person {fullName = fullName})

version' :: Lens Person Int
version' = Lens version (\person version -> person {version = version})

address' :: Lens Person Address
address' = Lens address (\person address -> person {address = address})

city' :: Lens Address String
city' = Lens city (\address city -> address {city = city})

rules :: Rule s a
rules = compose return return

ruleFor :: Lens s a -> Rule s a -> Rule s s
ruleFor l r s = do
  let a = getL l s
  a' <- r a
  let s' = setL l s a'
  modify (\ctx -> ctx {document = s'})
  return s'